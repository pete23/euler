cmdhistory=["(time (reduce + (map totient (range 2 8))))" "(time (reduce + (map totient (range 2 9))))" "(time (/ (reduce + (map totient (range 2 12001))) 2))" "(time (/ (reduce + (map totient (range 2 12001))) 6))" "(time (div (reduce + (map totient (range 2 12001))) 2))" "(time (div (div (reduce + (map totient (range 2 12001))) 2) 3))" "(farey-next 3 1/3 1/2)" "(farey-next 4 1/4 1/3)" "(farey-next 8 1/8 1/7)" "(farey-next 8 0/1 1/8)" "0/2" "(farey-next 8 0 1 1 8)" "(farey-sequence 4)" "(take 10 (farey-sequence 4))" "(take-while \#(<\= % 1) (farey-sequence 8))" "(farey-next 8 0 8 1 8)" "(farey-next 8 1 8 1 7)" "(take-while \#(<\= % 1) (farey-sequence 8))" "(take-while \#(<\= % 1) (farey-sequence 100))" "(drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 100)))" "(count (drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 12000))))" "(take-while \#(<\= % 1) (farey-sequence 10))" "(take-while \#(<\= % 1) (farey-sequence 11))" "(count (drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 120))))" "(count (drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 240))))" "(count (drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 480))))" "(count (drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 1200))))" "(count (drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 2400))))" "(count (drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 4800))))" "(time (count (drop-while \#(<\= % 1/3) (take-while \#(< % 1/2) (farey-sequence 12000)))))" "(defn farey-neighbour [n a b c d]\\n  (let [e (+ a c)\\n        f (+ b d)]\\n    [e f]))" "(farey-neighbour 12000 1 3 1 2)" "(time (count (take-while \#(< % 1/2) (farey-sequence 12000 1 3 4000 11999))))" "(euler-72-hard-recur)" "(time (euler-72-hard-recur))" "(get-triangles)" "(take 2 (get-triangles))" "(read \\"100\\")" "(read-string \\"100\\")" "(take 2 (get-triangles))" "(contains-origin (first (get-triangles)))" "(contains-origin (second (get-triangles)))" "(count (filter identity (map contains-origin (get-triangles))))" "(count (map contains-origin (get-triangles)))" "(- 1000 233)" "(count (filter identity (map contains-origin (get-triangles))))" "(euler-102)" "(count (filter true? (map contains-origin (get-triangles))))" "(twice-area-triangle (first (get-triangles)))" "(apply twice-area-triangle (first (get-triangles)))" "(contains-origin (first (get-triangles)))" "(contains-origin (second (get-triangles)))" "(twice-area-triangle [0 0] [1 0] [0 1])" "(twice-area-triangle [0 0] [2 0] [0 2])" "(twice-area-triangle [1 1] [3 1] [1 3])" "(twice-area-triangle [1 1] [3 1] [0 0])" "(contains-origin (first (get-triangles)))" "(contains-origin (second (get-triangles)))" "(euler-102)" "(time (euler-102))" "(def triangles (get-triangles))" "(time (count (filter true? (map contains-origin triangles))))" "(use 'criterium.core)" "(with-progress-reporting (bench (count (filter true? (map contains-origin triangles)))))" "(bench (count (filter true? (map contains-origin triangles))))" "(time (euler-72-hard-recur))" "(bench (euler-72-hard-recur))" "(time (euler-72-hard-recur))" "(use 'clojure.core.logic)" "(run* [q]\\n      (\=\= q true))" "(run* [q]\\n      (\=\= q q))" "(run* [q]\\n      (\=\= \\\\r q))" "(run* [q]\\n      (\=\= (+ r 1) q))" "(run* [q]\\n      (\=\= r 1)\\n      (\=\= (+ r 1) q))" "(run* [q]\\n      (membero q [1 2 3])\\n      (membero q [3 4 5]))" "(run* [q]\\n      (membero q [1 2 3])\\n      (membero q [2 3 4]))" ";; Switching to euler.core namespace" "(take 10 match-primes)" "(take 10 (match-primes))" ";; Switching to euler.sudoko namespace" "(first (read-boards))" "(first (first (read-boards)))" "(first (read-boards))" "(apply str (first (read-boards)))" "(first (read-boards))" "(-> (first (read-boards)) prep)" "(-> read-boards first prep print-board)" "(-> (read-boards) first prep print-board)" "(-> (read-boards) solve first prep print-board)" "(flatten [\\"1234\\" \\"2324\\"])" "(first (read-boards))" "(flatten [\\"1234\\" \\"2324\\"])" "(first (read-boards))" "(-> (read-boards) solve first prep print-board)" "(read-boards)" "(first (read-boards))" "(-> (read-boards) solve first prep print-board)" "(-> (read-boards) solve)" "(-> (read-boards) solve first)" "(-> (read-boards) solve first prep)" ";; Switching to euler.sudoko namespace" "(-> (read-boards) first)" "(-> (read-boards) first solve)" "(-> (read-boards) first solve prep print-board)" "(-> (read-boards) first solve)" "(-> (read-boards) first solve prep print-board)" "(-> (read-boards) first solve euler-solution)" "(reduce + (map euler-solution (read-boards)))" "(reduce + (pmap euler-solution (read-boards)))" "(time  (reduce + (map euler-solution (read-boards))))" "(time  (reduce + (pmap euler-solution (read-boards))))" "(-> (read-boards) first solve-logically prep print-board)" "(-> (read-boards) first solve-logically)" "(-> (read-boards) first)" "(-> (read-boards) first solve-logically)" "'-" "(-> (read-boards) first solve-logically)" "(solve-logically pn)" "(solve-logically b1)" "pn" "(first pn)" "(type (first pn))" "(solve-logically b1)" "(solve-logically pn)" "(replace {0 '-} (first (read-boards)))" "(solve-logically (replace {0 '-} (first (read-boards))))" "(solve-logically (first (read-boards)))" "(euler-solution (first (read-boards))\\n                )" "(time  (reduce + (pmap euler-solution (read-boards))))" "(time  (reduce + (map euler-solution (read-boards))))" "(* 160 251 12)" "(take 5 (match-primes))" "(concat-numbers 123 435)" "(concatted-prime 2 3)" "(concatted-prime 3 7)" "(take 100 match-primes)" "(take 100 (match-primes))" "(take 10 (map \#(clojure.math.combinatorics/combinations % 2) (match-primes)))" "(every? concatted-prime '((11 7) (11 5) (11 3) (7 5) (7 3) (5 3)))" "(every? (map \#(apply concatted-prime %) '((11 7) (11 5) (11 3) (7 5) (7 3) (5 3))))" "(every? identity (map \#(apply concatted-prime %) '((11 7) (11 5) (11 3) (7 5) (7 3) (5 3))))" "(prime? 35)" "(every? concatted-prime? '((11 7) (11 5) (11 3) (7 5) (7 3) (5 3)))" "(all-concattable? '(3 7 109 673))" "(some (map all-concattable? (match-primes)))" "(some all-concattable? (match-primes))" "(prime? 1753)" "(prime? 5317)" "(prime? (concat-numbers 53 17))" "(concatted-prime 53 17)" "(prime? (concat-numbers 53 17))" "(some all-concattable? (match-primes))" "(time (some all-concattable? (match-primes)))" "(euler-xxx)" "(oracle-prime? 3)" "(oracle-prime? 17)" "(oracle-prime? 19)" "(oracle-prime? 21)" "(euler-xxx)" "(pair-primes)" "(def paired-primes (pair-primes))" "(map \#(apply * %) paired-primes)" "(set (map \#(apply * %) paired-primes))" "(set 1 2 3)" "(set [1 2 3])" "((set [1 2 3]) 3)" "((set [1 2 3]) 4)" "(map * [[1 2] [3 4]])" "(combo-product [1 2 3 4])" "(euler-xxx)" "(take 5 (concat-prime-pair-products))" "(euler-xxx)" "(count (concat-prime-pair-products))" "(count primes-not-2)" "(take 4 (concat-prime-pair-products))" "(take 1 (concat-prime-pair-products))" "(concat [1 2] [3 4])" "(hashmap (concat [1 2] [3 4]))" "(hash-map (concat [1 2] [3 4]))" "(apply hash-map (concat [1 2] [3 4]))" "(def round-one (concat-prime-pair-products))" "round-one" "(take 5 round-one)" "(apply concat (take 5 round-one))" "(apply sorted-map (apply concat (take 5 round-one)))" "(def round-one (concat-prime-pair-products))" "(apply sorted-map (apply concat (take 5 round-one)))" "(def round-one (concat-prime-pair-products))" "(take 1 round-one)" "(let [n (take 1 round-one)\\n     m (first n)\\n     s (second n)]\\n (filter not-empty\\n         (for [o s\\n               s2 (round-one o)]\\n           (clojure.set/intersection s s2))))" "(let [n (take 1 round-one)\\n     m (first n)\\n     s (second n)]\\n         (for [o s\\n               s2 (round-one o)]\\n           (clojure.set/intersection s s2)))" "(let [n (take 1 round-one)\\n     m (first n)\\n     s (second n)]\\n  [m s])" "(let [n (first (take 1 round-one))\\n     m (first n)\\n     s (second n)]\\n  (filter not-empty\\n         (for [o s\\n               s2 (round-one o)]\\n           (clojure.set/intersection s s2))))" "(round-one 3)" "(clojure.set/intersection (round-one 3) (round-one 5281))" "(clojure.set/intersection (round-one 3) (round-one 6529))" "(clojure.set/intersection (round-one 3) (round-one 6529) (round-one 449))" "(clojure.set/intersection (round-one 3) (round-one 449))" "(round-one 449)" "(clojure.set/intersection (round-one 449) (round-one 2273))" "(count round-one)" "(let [s (round-one 3)]\\n  (map \#(clojure.set/intersection s %) (map round-one s)))" "(count (let [s (round-one 3)]\\n         (map \#(clojure.set/intersection s %) (map round-one s))))" "(count (prime-pairs))" "(defn prime-triples []\\n  (filter identity (for [[a b] (prime-pairs)\\n                         c primes-not-2 \:while (< c b)]\\n                     (if (and (concatted-prime? a c)\\n                              (concatted-prime? b c)) [a b c]))))" "(count (prime-triples))" "(time (def pairs (prime-pairs)))" "(time (def pair-oracle (convert-pairs-to-factor-set pairs)))" "(def triples (filter identity\\n               (for [[a b] pairs\\n                     c primes-not-2 \:while (< c b)]\\n                 (if (and (pair-oracle (* a c))\\n                          (pair-oracle (* b c)))\\n                   [a b c]))))" "(take 10 triples)" "(def quadriples (filter identity\\n                   (for [[a b c] triples\\n                         d primes-not-2 \:while (< d c)]\\n                     (if (and (pair-oracle (* a d))\\n                              (pair-oracle (* b d))\\n                              (pair-oracle (* c d)))\\n                       [a b c d]))))" "(take 10 quadriples)" "(def quintiples (filter identity\\n                   (for [[a b c d] quads\\n                         e primes-not-2 \:while (< e d)]\\n                     (if (and (pair-oracle (* a e))\\n                              (pair-oracle (* b e))\\n                              (pair-oracle (* c e))\\n                              (pair-oracle (* d e)))\\n                       [a b c d e]))))" "(def quintiples (filter identity\\n                   (for [[a b c d] quadriples\\n                         e primes-not-2 \:while (< e d)]\\n                     (if (and (pair-oracle (* a e))\\n                              (pair-oracle (* b e))\\n                              (pair-oracle (* c e))\\n                              (pair-oracle (* d e)))\\n                       [a b c d e]))))" "(take 2 quintiples)" "(count quadriples)" "(count triples)" "(first quintiples)" "(apply + (first quintiples))" "(map seq '(1 2 3 4 5))" "(map vec '(1 2 3 4 5))" "(map vector '(1 2 3 4 5))" "(def match-one-round [predicate values to-test]\\n  (if (every? (partial predicate to-test) values)\\n    (conj values to-test)))" "(defn match-one-round [predicate values to-test]\\n  (if (every? (partial predicate to-test) values)\\n    (conj values to-test)))" "(match-one-round \#(pair-oracle (* %1 %2)) [8389 6733 5701 5197] 13)" "(match-one-round \#(pair-oracle (* %1 %2)) [8389 6733 5701] 13)" "(match-one-round \#(pair-oracle (* %1 %2)) [8389 6733 5701] 14)" "(match-one-round \#(pair-oracle (* %1 %2)) [8389 6733 5701 5197] 13)" "(take 10 (prime-pairs))" "concatted-prime?" "match-whole" "(match-whole)" "(time (euler-xxx))" "(time (first (euler-xxx)))" "(time (euler-60))" "(time (doseq (match-whole concatted-prime? primes-in-scope (map vector primes-in-scope))))" "(time (last (match-whole concatted-prime? primes-in-scope (map vector primes-in-scope))))" "(euler-60)" "(time (euler-60)\\n      )" "(euler-60)" "(def qp (take-while \#(< % 10000) (drop 1 primes)))" "(count qp)" "(time (count (pairs-quickly concatted-prime? qp)))" "(time (count (match-whole concatted-prime? qp (map vector qp))))" "(time (euler-60))" "(+ 1/2 2)" "(/ 1 (+ 1/2 2))" "(sqrt-2-expansion 1)" "(sqrt-2-expansion 2)" "(convergence-sequence 1 1 (repeatedly 2))" "(convergent-sequence 1 1 (repeatedly 2))" "(take 5(constantly 2))" "(constantly 2)" "(repeat 2)" "(take 5 (repeat 2))" "(convergent-sequence 1 1 (repeat 2))" "(convergent-sequence 2 1 (repeat 2))" "(take 2 (continued-fraction-for-e))" "(take 9 (continued-fraction-for-e))" "(convergent-sequence 1 2 (continued-fraction-for-e))" "(convergent-sequence 2 2 (continued-fraction-for-e))" "(convergent-sequence 3 2 (continued-fraction-for-e))" "(convergent-sequence 0 2 (continued-fraction-for-e))" "(convergent-sequence 0 (dec 2) (continued-fraction-for-e))" "(convergent-sequence 1 (dec 2) (continued-fraction-for-e))" "(convergent-sequence 0 2 (continued-fraction-for-e))" "(convergent-sequence 1 2 (continued-fraction-for-e))" "(convergent-sequence 2 2 (continued-fraction-for-e))" "(convergent-sequence 3 2 (continued-fraction-for-e))" "(convergent-sequence 4 2 (continued-fraction-for-e))" "(+ 2 (/ 1 1))" "(+ 2 (/ 1 (+ 1 (/ 1 2))))" "(convergent-sequence 2 '())" "(convergent-sequence 2 (take 1 (continued-fraction-for-e)))" "(convergent-sequence 2 (take 2 (continued-fraction-for-e)))" "(convergent-sequence 2 (take 3 (continued-fraction-for-e)))" "(convergent-sequence 2 (take 4 (continued-fraction-for-e)))" "(map \#(convergent-sequence 2 (take % (continued-fraction-for-e))))" "(take 10 (map \#(convergent-sequence 2 (take % (continued-fraction-for-e))) range))" "(take 10 (map \#(convergent-sequence 2 (take % (continued-fraction-for-e))) (range)))" "(nth 10 (map \#(convergent-sequence 2 (take % (continued-fraction-for-e))) (range)))" "(nth (map \#(convergent-sequence 2 (take % (continued-fraction-for-e))) (range)) 10)" "(nth (map \#(convergent-sequence 2 (take % (continued-fraction-for-e))) (range)) 9)" "(nth (map \#(convergent-sequence 2 (take % (continued-fraction-for-e))) (range)) 99)" "(take 10 (convergent-sequence 2 (continued-fraction-for-e)))" "(euler-65)" "23423423423423432/10" "(div 23432434342 10)" "(/ 2342323423423423 10)" "(div' 23423232342342342343223423423423432423423434423423423 10)" "(/ 23423232342342342343223423423423432423423434423423423 10)" "(/' 23423232342342342343223423423423432423423434423423423 10)" "(quot 23423232342342342343223423423423432423423434423423423 10)" "(digits 23423232342342342343223423423423432423423434423423423)" "(euler-65)" "(time (euler-65))" "(n-rects 3 2)" "(n-rects 4 3)" "(n-rects 3 2)" "(n-rects 2000 1)" "(n-rects 20000 1)" "(euler-85)" "java.lang.Math/abs" "(euler-85)" "(time (euler-85))" "(use 'criterium.core)" "(bench (euler-85))" "(euler-85)" "(n-rects 2000 1)" "(n-rects 1999 1)" "(n-rects 1999 2)" "(n-rects 1400 2)" "(n-rects 1000 2)" "(n-rects 100 100)" "(euler-85)" "(n-rects 171 16)" "(n-rects 170 16)" "(n-rects 172 15)" "(* 171 16)" "(* 173 16)" "(euler-85)" "(closest-x-for-y 1)" "(n-rects 8000000)" "(n-rects 8000000 1)" "contains-origin" "(quadratic-solution 2 2 8000000)" "(quadratic-solution 2 2 -8000000)" "(closest-x-for-y 1)" "(closest-x-for-y 2)" "(n-rects 1155 2)" "(n-rects 1156 2)" "(n-rects 1155 2)" "(n-rects 1154 2)" "(map closest-x-for-y (range 2000))" "(map closest-x-for-y (range 1 2000))" "(map n-rects (map closest-x-for-y (range 1 2000)) (range 1 2000))" "(euler-85)" "(e-85-f-c 2000000)" "(n-rects 4 816)" "(n-rects 3 816)" "(* 3 816)" "(euler-85)" "(* 171 16)" "(n-rects 171 16)" "(e-85-f-c 2000000)" "(n-rects 280703/70176 816)" "(e-85-f-c 2000000)" "(n-rects 77 36)" "(closest-x-for-y 36)" "(e-85-f-c)" "(e-85-f-c 2000000)" "(closest-x-for-y 77)" "(quadratic-solution (* 77 78) (* 77 78) -8000000)" "(e-85-f-c 2000000)" "(closest-x-for-y 23)" "(* 23 (closest-x-for-y 23))" "(* 77 (closest-x-for-y 77))" "(e-85-f-c 2000000)" "(count (take-while \#(< (* % %) 50000000) primes))" "(combinations 908 3)" "(count (combinations (take-while \#(< (* % %) 50000000) primes)))" "(count (combinations (take-while \#(< (* % %) 50000000) primes) 3))" "(count (take-while \#(< % 50000000) (map \#(* % %) primes)))" "(count (take-while \#(< % 50000000) (map \#(* % % %) primes)))" "(count (take-while \#(< % 50000000) (map \#(* % % % %) primes)))" "(* 908 73 23)" "(count (for [s (take-while \#(< % 50000000) (map \#(* % %) primes))\\n             t (take-while \#(< % 50000000) (map \#(* % % %) primes))]\\n         (+ s t)))" "(count (for [s (take-while \#(< % 50000000) (map \#(* % %) primes))\\n             t (take-while \#(< % 50000000) (map \#(* % % %) primes))\\n             u (take-while \#(< % 50000000) (map \#(* % % % %) primes))]\\n         (+ s t u)))" "(count (filter \#(< % 5000000) (for [s (take-while \#(< % 50000000) (map \#(* % %) primes))\\n                                    t (take-while \#(< % 50000000) (map \#(* % % %) primes))\\n                                    u (take-while \#(< % 50000000) (map \#(* % % % %) primes))]\\n                               (+ s t u))))" "(count (set (filter \#(< % 5000000) (for [s (take-while \#(< % 50000000) (map \#(* % %) primes))\\n                                         t (take-while \#(< % 50000000) (map \#(* % % %) primes))\\n                                         u (take-while \#(< % 50000000) (map \#(* % % % %) primes))]\\n                                    (+ s t u)))))" "(euler-87)" "(time (euler-87))" "(exact-integer-sqrt 23)" "(+ (* 4 4) 7)" "(exact-integer-sqrt 23)" "(floor (/ 1 (- (sqrt 23) 4)))" "(floor (/ 2 (- (sqrt 23) 3)))" "(floor (/ 2 (+ (sqrt 23) 3)))" "(/ 49 14)" "(floor (/ 49 14))" "(defn step [n multiplicand additive]\\n  (floor (* multiplicand (+ (sqrt n) additive))))" "(step 23 7/14 3)" "(step 23 2/14 3)" "(step 23 7/7 4)" "(defn step [n multiplicand additive]\\n  (let [digit (floor (* multiplicand (+ (sqrt n) additive)))\\n        new-additive (- (* multiplicand additive) digit)\\n        new-divisor (/ 1 multiplicand)]\\n    [digit new-additive new-divisor]))" "(step 23 2/14 3)" "(step 23 7/7 3)" "(step 23 7/7 4)" "(defn ur-step [n [digit additive divisor]]\\n  (let [multiplicand (/ (- n (* additive additive)) divisor)\\n        additive (- additive)]\\n    [multiplicand additive]))" "(ur-step 27 [4 -4 1/1])" "(* -4 -4)" "(- 23 16)" "(step 23 1 -4)" "(step 23 1/1 -4)" "(step 23 1/7 4)" "(+ (sqrt 23) -4)" "(floor (/ (+ (sqrt 23) 4) 7))" "(step 23 1/7 4)" "(defn step [n multiplicand additive]\\n  (let [digit (int (* multiplicand (+ (sqrt n) additive)))\\n        new-additive (- (* multiplicand additive) digit)\\n        new-divisor (/ 1 multiplicand)]\\n    [digit new-additive new-divisor]))" "(step 23 1/7 4)" "(* -3/7 7N)" "(defn step [n multiplicand additive]\\n  (let [digit (int (* multiplicand (+ (sqrt n) additive)))\\n        new-additive (/ (- (* multiplicand additive) digit) multiplicand)\\n        new-divisor (/ 1 multiplicand)]\\n    [digit new-additive new-divisor]))" "(step 23 1/7 4)" "(step 23 4 -4)" "(ur-step 23 4 -4)" "(ur-step 23 [0 4 -4])" "(ur-step 23 [0 1 -4])" "(step 23 1 -4)" "(/ 1 (- 23 (* 4 4)))" "(int (* 1/7 (+ (sqrt 23) 4)))" "(step 23 1/1 -4)" "(step 23 -4 1/1)" "(step 23 -3N 7N)" "(root-continued-fraction-seq 23)" "(root-continued-fraction-seq 2)" "(root-continued-fraction-seq 3)" "(root-continued-fraction-seq 5)" "(root-continued-fraction-seq 6)" "(root-continued-fraction-seq 7)" "(root-continued-fraction-seq 8)" "(root-continued-fraction-seq 11)" "(root-continued-fraction-seq 4)" "(euler-64 13)" "(exact-integer-sqrt 0)" "(take 10 (filter \#(> 0 (second (exact-integer-sqrt %))) (range)))" "(euler-64 13)" "(map count (euler-64 13))" "(filter odd? (map count (euler-64 13)))" "(euler-64 13)" "(euler-64 10000)" "(time (euler-64 10000))" "1.234242342342342342342342342342342342342342342342342342423423423423423N" "1.23423423423423423423423423423423423423423423423423" "1.23423423432423423432423432423423423423423B" "1.23423423432423423432423432423423423423423M" "1.23423423432423423432423432423423423423423M/1.231232131231312321312321321312312312M" "(/ 1.23423423432423423432423432423423423423423M 1.231232131231312321312321321312312312M)" "(reduce + [1])" "(map + [1] (rest [1]))" "(map + [1 2] (rest [1 2]))" "(defn pascal-odd-to-even-step [n]\\n  (map + (concat '(1) n) n))" "(pascal-odd-to-even-step [])" "(pascal-odd-to-even-step [2])" "(pascal-odd-to-even-step [5 10])" "(defn pascal-step [n]\\n  (map + (concat '(1) n) n))" "(pascal-step [2])" "(concat (pascal-step [3]) (* 2 3))" "(conj (pascal-step [3]) (* 2 3))" "(cons (pascal-step [3]) (* 2 3))" "(conj (vec (pascal-step [3])) (* 2 3))" "(pascal-step [4 6])" "(conj (vec (pascal-step [5 10]) (* 2 10)))" "(conj (vec (pascal-step [5 10])) (* 2 10))" "(take 5 pascal)" "(take 5 (pascal))" "(take 1 pascal)" "(take 1 (pascal))" "(take 2 (pascal))" "(take 3 (pascal))" "(take 6 (pascal))" "(take 1 pascal)" "(take 6 (pascal))" "(last (take 49 (pascal)))" "(take 5 pascal)" "(take 5 (pascal))" "(concat (take 5 (pascal)))" "(mapcat (take 5 (pascal)))" "(mapcat identity (take 5 (pascal)))" "(concat (take 5 (pascal)))" "(count (distinct-in-rows 8))" "(defn prime-squares (map \#(* % %) primes))" "(def prime-squares (map \#(* % %) primes))" "(take 100 prime-squares)" "(filter divisible-by-prime-square? (distinct-in-rows 8))" "(divisible-by-prime-square? 4)" "(divisible-by-prime-square? 20)" "(divisible-by-prime-square? 4)" "(filter divisible-by-prime-square? (distinct-in-rows 8))" "(reduce + (filter divisible-by-prime-square? (distinct-in-rows 8)))" "(reduce + (filter not-divisible-by-prime-square? (distinct-in-rows 8)))" "(filter divisible-by-prime-square? (distinct-in-rows 8))" "(filter divisible-by-prime-square? (distinct-in-rows 20))" "(filter divisible-by-prime-square? (distinct-in-rows 51))" "(count (filter divisible-by-prime-square? (distinct-in-rows 51)))" "(count (filter \#(not (divisible-by-prime-square? %)) (distinct-in-rows 51)))" "(reduce + (filter \#(not (divisible-by-prime-square? %)) (distinct-in-rows 51)))" "(take 5 (pascal))" "(take 10 (pascal))" "(time (euler-203))" "(take 6 (pascal))" "(flatten (take 6 (pascal)))" "(** 2 10)" "(generate-hamming-numbers-less-than 5)" "(+ 1 1)" "(carry [1 0 0])" "(short-array 3)" "(persistent\! nil)" "(carry [0 1 0])" "(carry [0 0 1])" "(carry [0 5 0])" "(vec-inc [0 0 0])" "(vec-inc [1 0 0])" "(carry [2 0 0])" "(pow 2 16)" "(pow 2 32)" "(product [1 1 1] [2 3 5])" "(product [2 3 5] [1 1 1])" "(hamming-numbers-less-than 5 16)" "(sort (hamming-numbers-less-than 5 16))" "(sort (hamming-numbers-less-than 6 16))" "(count (hamming-numbers-less-than 5 100))" "(count (hamming-numbers-less-than 5 1000))" "(count (hamming-numbers-less-than 5 10000))" "(count (hamming-numbers-less-than 5 100000))" "(count (hamming-numbers-less-than 5 1000000))" "(count (hamming-numbers-less-than 5 10000000))" "(count (hamming-numbers-less-than 5 100000000))" "(count (hamming-numbers-less-than 100 100000000))" "(count (hamming-numbers-less-than 5 100000000))" "(count (hamming-numbers-less-than 100 1000000000))" "(time (count (hamming-numbers-less-than 100 1000000000)))" "(expt 2 8)" "(time (count (hamming-numbers-less-than 100 1000000000)))" "(map * (int-array 6))" "(map pow (int-array 6))" "(map pow (int-array 6) (int-array 6))" "(time (count (hamming-numbers-less-than 100 10000000)))" "(time (count (hamming-numbers-less-than 100 100000000)))" "(time (count (hamming-numbers-less-than 100 1000000000)))" "(hamming-numbers-less-than 100 100000)" "(def a (short-array 5))" "(aset a 5 2)" "(aset\! a 5 2)" "(hamming-numbers-less-than 100 100000)" "(create-counter 4)" "(counter-create 4)" "(counter-inc (counter-create 4))" "(hamming-numbers-less-than 100 100000)" "(count (hamming-numbers-less-than 100 100000))" "(count (hamming-numbers-less-than 100 1000000))" "(count (hamming-numbers-less-than 100 10000000))" "(time (count (hamming-numbers-less-than 100 100000000)))" "(time (count (hamming-numbers-less-than 100 1000000000)))" "(denominator 5/10)" "(defn resilience [n]\\n  (map \#(/ % n) (range 1 (dec n))))" "(resilience 12)" "(defn resilience [n]\\n  (map \#(/ % n) (range 1 n)))" "(resilience 12)" "(defn resilience [n]\\n  (/ (count (filter \#(\= (denominator %) n) (map \#(/ % n) (range 1 n)))) (dec n)))" "(resilience 12)" "(resilience 1200)" "(resilience 20000)" "15499/94744" "(double 15499/94744)" "(double 8000/19999)" "(some \#(< (resilience %) 15499/94744) (range 1 100))" "(some \#(< (resilience %) 15499/94744) (range 2 100))" "(some \#(< (resilience %) 15499/94744) (range 2 1000))" "(some \#(< (resilience %) 15499/94744) (range 2 10000))" "(some \#(< (resilience %) 15499/94744) (range 2 100000))" "\\n(map \#(double (resilience %)) (range 2 1000))" "\\n(map \#(double (resilience %)) (range 100000 100020))" "\\n(map \#(double (resilience %)) (range 1000000 1000020))" "(some \#(< (resilience %) 15499/94744) (range 2 100000))" "(rem 40)" "(rem 12 40)" "(rem 45 40)" "(rem -2 40)" "(assoc {} \:location 234)" "(euler-84)" "(nth 0 [1])" "(euler-84)" "(nth monopoly-board 23)" "(euler-84)" "(interpose 0 (range 40))" "(interpose 0 (range 41))" "(euler-84)" "(update-in {} [3] inc)" "(update-in {3 0} [3] inc)" "(new-freqs)" "(euler-84)" "(rotate [1 2 3])" "(partial mono-move -3)" "(shuffle [1 2 3])" "(new-monopoly)" "(euler-84)" "(sort {1 23 5 21})" "(sort second {1 23 5 21})" "(sort \#(comp (second %1) (second %2)) {1 23 5 21})" "(sort \#(compare (second %1) (second %2)) {1 23 5 21})" "(euler-84)" "(defn go-to-jail [game] game)" "(defn chest [game] game)" "(defn chance [game] game)" "(euler-84)" "chest" "(def g (new-monopoly))" "g" "(mono-square 24)" "(nth monopoly-board 24)" "g" "(monopoly-card \:chest g)" "(monopoly-card \:chance g)" "g" "(monopoly-card \:chest (assoc game \:location 5))" "(monopoly-card \:chest (assoc g\\n                         \:location 5))" "(rotate (\:chest g))" "(euler-84)" "(go-to-one-of g \:r1 \:b1)" "(go-to-one-of g (set [\:r1 \:b1]))" "(go-to-one-of g (set [\:b1]))" "(euler-84)" "(go-to-one-of g (set [\:r1 \:b1]))" "[(inc (rand-int 6)) (int (rand-int 6))]" "(euler-84)" "(apply \=\= [1 1])" "(apply \=\= [1 2])" "(new-monopoly)" "(def g (new-monopoly))" "g" "(chance g)" "(chest g)" "(source chest)" "(chest g)" "(chance g)" "(euler-84)" "(time (euler-84))" "(sort \\"DSFDSFDSF\\")" "(str (sort \\"DFDFSDFSFFS\\"))" "(join (sort \\"DFDFSDFSFFS\\"))" "(clojure.string/join (sort \\"DFDFSDFSFFS\\"))" "(euler-98)" "(update-in {} [\\"FOO\\"] \#(inc 1))" "(update-in {} [\\"FOO\\"] \#(inc 1 %))" "(update-in {} [\\"FOO\\"] \#(inc %))" "(update-in {} [\\"FOO\\"] \#(if (nil? %) 1 (inc %)))" "(euler-98)" "(sort \#(compare (count (second %1)) (count (second %2))) (euler-98))" "(euler-98)" "(euler-84)" "(euler-98)" "(map \#(* % %) (range 10000))" "(euler-98)" "(map \#(* % %) (range 20000))" "(map \#(* % %) (range 30000))" "(euler-98)" "(map \#(* % %) (range 30000))" "(map \#(* % %) (range 33334))" "(map \#(* % %) (range 33000))" "(map \#(* % %) (range 31000))" "(map \#(* % %) (range 32000))" "(map \#(* % %) (range 31500))" "(map \#(* % %) (range (sqrt 10000000)))" "(map \#(* % %) (range (sqrt 100000000)))" "(map \#(* % %) (range (sqrt 1000000000)))" "(map \#(* % %) (range (sqrt 100000000) (sqrt 1000000000)))" "(reduce (build-ana-map-fn \#(sort (digits %))) {} (map \#(* % %) (range (sqrt 100000000) (sqrt 1000000000))))" "(map second (reduce (build-ana-map-fn \#(sort (digits %))) {} (map \#(* % %) (range (sqrt 100000000) (sqrt 1000000000)))))" "(filter \#(< 1 (count %)) (map second (reduce (build-ana-map-fn \#(sort (digits %))) {} (map \#(* % %) (range (sqrt 100000000) (sqrt 1000000000))))))" "(count (filter \#(< 1 (count %)) (map second (reduce (build-ana-map-fn \#(sort (digits %))) {} (map \#(* % %) (range (sqrt 100000000) (sqrt 1000000000)))))))" "(index-of \\"asdf\\" \\\\f)" "(ana-transformer \\"CARE\\" \\"RACE\\")" "(euler-98)" "(reverse (euler-98))" "(euler-98-test-group [2 nil])" "(euler-98-test-group [3 nil])" "(euler-98-test-group [9 nil])" "(pow 10 9)" "(take 5 (euler-98-test-group [9 nil]))" "(count (filter \#(< 1 (count %)) (map second (reduce (build-ana-map-fn \#(sort (digits %))) {} (map \#(* % %) (range (sqrt 100000000) (sqrt 1000000000)))))))" "(euler-98-test-group [1 nil])" "(filter \#(< 1 (count %)) (map second (reduce (build-ana-map-fn \#(sort (digits %))) {} (map \#(* % %) (range (sqrt (pow 10 1)) (sqrt (pow 10 (inc 1))))))))" "(count (range (sqrt (pow 10 1)) (sqrt (pow 10 2))))" "(map \#(* % %) (range (sqrt (pow 10 1) (sqrt (pow 10 2)))))" "(pow 10 2)" "(pow 10 3)" "(map \#(* % %) (range (sqrt (pow 10 1) (sqrt (pow 10 2)))))" "(count (range (sqrt (pow 10 1)) (sqrt (pow 10 2))))" "(map \#(* % %) (range (sqrt (pow 10 1)) (sqrt (pow 10 2))))" "(take 5 (range-squares-length 3))" "(take-last 5 (range-squares-length 3))" "(take 5 (range-squares-length 3))" "(take-last 5 (range-squares-length 9))" "(take-last (squares-of-length 3))" "(take-last 1 (squares-of-length 3))" "(take 1 (squares-of-length 3))" "(take 1 (squares-of-length 4))" "(take-last 1 (squares-of-length 4))" "(euler-98-test-group [2 nil])" "(euler-98-test-group [3 nil])" "(euler-98-test-group [9 nil])" "(time (euler-98-test-group [9 nil]))" "(mapcat \#(combinations % 2) [[1 2] [4 5 6]])" "(euler-98)" "(map ana-transformer (euler-98))" "(map ana-transformer [[\\"POST\\" \\"SPOT\\" \\"STOP\\"]])" "(euler-98)" "(group-by \#(count (first %)) (euler-98))" "(euler-98)" "(take 1 (euler-98))" "(take 2 (euler-98))" "(build-ana (squares-of-length 4) \#(sort (digits %)))" "(build-ana-from-words)" "(ana-transformer [\\"CARE\\" \\"RACE\\"])" "(ana-form '(2 1 0 3) 1296)" "(ana-form '(2 1 0 3) 2916)" "(group-by \#(count (first %)) ana)" "(group-by \#(count (first %)) (build-ana-from-words))" "(euler-98-test-group [9 [[\\"INTRODUCE\\" \\"REDUCTION\\"]]])" "(ana-transformer [\\"INTRODUCE\\" \\"REDUCTION\\"])" "(match-ana-groups '((3 8 5 6 7 2 0 4 1)) '(202977009 770229009))" "(check-haystack '((3 8 5 6 7 2 0 4 1)) '((202977009 770229009)))" "(check-haystack '((3 8 5 6 7 2 0 4 1)) (build-ana (squares-of-length size) \#(sort (digits %))))" "(check-haystack '((3 8 5 6 7 2 0 4 1)) (build-ana (squares-of-length 9) \#(sort (digits %))))" "(euler-98)" "(check-haystack '((3 8 5 6 7 2 0 4 1)) (build-ana (squares-of-length 9) \#(sort (digits %))))" "(euler-98)" "(euler-98-test-group [[9 \\"ABCDEFGHI\\" \\"GHIDEFABC\\"]])" "(euler-98-test-group [9 [\\"ABCDEFGHI\\" \\"GHIDEFABC\\"]])" "(euler-98-test-group [9 [[\\"ABCDEFGHI\\" \\"GHIDEFABC\\"]]])" "(euler-98)" "(take 5 (root-continued-fraction-seq 2))" "(take 20 (convergent-sequence 1 (root-continued-fraction-seq 2)))" "(take 20 (convergent-sequence 2 (root-continued-fraction-seq 2)))" "(take 20 (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))))" "(take 200 (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))))" "(nth 100 (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))))" "(nth (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))) 100)" "(nth (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))) 150)" "(nth (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))) 200)" "(let [frac (nth (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))) 200)] (/ (numerator frac) (denominator frac)))" "(let [frac (nth (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))) 200)] (/ (double (numerator frac)) (denominator frac)))" "(let [frac (nth (convergent-sequence 1 (cycle (root-continued-fraction-seq 2))) 200)] (/ (bigdec (numerator frac)) (denominator frac)))" "(filter (comp square?) (range 1 1001))" "(filter (complement square?) (range 1 1001))" "(take 4 (root-continued-fraction-seq 7))" "(root-continued-fraction-seq 7)" "(step 7 -2 1/1)" "(step 7 -1 3)" "(take 5 (convergent-sequence 1 (continued-fraction-for-sqrt-2)))" "(take 5 (convergent-sequence 1 continued-fraction-for-sqrt-2))" "(root-continued-fraction-seq 2)" "(root-continued-fraction-seq 4)" "(root-continued-fraction-seq 5)" "(root-continued-fraction-seq 7)" "(root-continued-fraction-seq 102)" "(take 5 (convergent-root-sequence 7))" "((pell-solution? 7) 8 3)" "(minimal-pell-solution 7)" "((pell-solution? 7) 8/3)" "(minimal-pell-solution 7)" "(non-squares-less-than 8)" "(map \#([(numerator (minimal-pell-solution %)) %]) (non-squares-less-than 8))" "(map \#(numerator (minimal-pell-solution %)) (non-squares-less-than 8))" "(map \#(vector (numerator (minimal-pell-solution %)) %) (non-squares-less-than 8))" "(sort (map \#(vector (numerator (minimal-pell-solution %)) %) (non-squares-less-than 8)))" "(last (sort (map \#(vector (numerator (minimal-pell-solution %)) %) (non-squares-less-than 8))))" "(last (sort (map \#(vector (numerator (minimal-pell-solution %)) %) (non-squares-less-than 1001))))" "(time (euler-66))" "(take 4 pentagons)" "(general-pentagon -1)" "(take 210 (interpose (range 1) (range -1)))" "(take 210 (interleave (range 1) (range -1)))" "(take 210 (interleave (range) (range)))" "(take 210 (interleave (range) (map - (range))))" "(drop 2 (take 210 (interleave (range) (map - (range)))))" "(take 4 general-pentagons)" "(integer-partition 2)" "(integer-partition 1)" "(integer-partition 2)" "(take-while \#(> 0 %) (map \#(- n %) general-pentagons))" "(take-while \#(> 0 %) (map \#(- 2 %) general-pentagons))" "(take 2 (map \#(- 2 %) general-pentagons))\\n()" "(integer-partition 2)" "(integer-partition 3)" "(integer-partition 5)" "(integer-partition 6)" "(take-while \#(> % 0) (map \#(- 2 %) general-pentagons))" "(integer-partition 6)" "(integer-partition 3)" "(integer-partition 2)" "(integer-partition 4)" "(integer-partition 5)" "(map integer-partition (take-while \#(<\= 0 %) (map \#(- n %) general-pentagons)))" "(map integer-partition (take-while \#(<\= 0 %) (map \#(- 5 %) general-pentagons)))" "(map * '(5 3 1) (cycle [1 1 -1 -1]))" "(integer-partition 5)" "(integer-partition 10000)" "(integer-partition 100)" "(integer-partition 1000)" "(integer-partition 200)" "(integer-partition 300)" "(integer-partition 400)" "(integer-partition 500)" "(integer-partition 600)" "(integer-partition 700)" "(integer-partition 800)" "(integer-partition 900)" "(some \#(if (\=\= 0 (mod (integer-partition %) 1000000)) %) (range))\\n(integer-partition 1000)" "(integer-partition 1010)" "(integer-partition 1100)" "(integer-partition 1200)" "(integer-partition 1300)" "(integer-partition 29)" "(integer-partition 101)" "(integer-partition 1010)" "(take 100 (map integer-partition primes))" "(mod 3123123120000000000000N 1000000N)" "(integer-partition 1200)" "(integer-partition 1300)" "(integer-partition 2000)" "(integer-partition 3000)" "(integer-partition 4000)" "(integer-partition 5000)" "(integer-partition 10000)" "(integer-partition 100000)" "(integer-partition 50000)" "(integer-partition 30000)" "(integer-partition 20000)" "(integer-partition 25000)" "(integer-partition 30000)" "(integer-partition 27500)" "(integer-partition 30000)" "(integer-partition 29000)" "(integer-partition 28500)" "(integer-partition 29000)" "(integer-partition 30000)" "(integer-partition 29500\\n                   )" "(time (some \#(if (\=\= 0 (mod (integer-partition %) 1000000)) %) (range)))" "(sqrt-to-digits 2 100)" "(digit-sum 512)" "(digit-sum 614656)" "(digit-power-sum 512)" "(digit-power-sum 511)" "(> 0 (mod 7 7))" "(> 0 (mod 49 7))" "(> 0 (mod 48 7))" "(mod 48 7)" "(< 0 6)" "(< 0 0)" "(digit-power-sum 511)" "(digit-power-sum 512)" "(sqrt-to-digits 2 100)" "(filter digit-power-sum (range 10000))" "(filter digit-power-sum (range 100))" "(digit-power-sum 1)" "(digit-power-sum 2)" "(digit-power-sum 3)" "(digit-power-sum 4)" "(digit-power-sum 5)" "(digit-power-sum 10)" "(filter digit-power-sum (range 100))" "(filter digit-power-sum (range 1000))" "(filter digit-power-sum (range 10000))" "(filter digit-power-sum (range 100000))" "(filter digit-power-sum (range 10 100000))" "(filter digit-power-sum (range 9 100000))" "(filter digit-power-sum (range 9 100000000))" "(filter digit-power-sum (range 9 10000000))" "(filter digit-power-sum (range 9 1000000))" "(some digit-power-sum (map (* % % % % % % %) (range)))" "(some digit-power-sum (map \#(*' % % % % % % %) (range)))" "(some digit-power-sum (map \#(*' % % % % % % %) (range 1 100)))" "(some digit-power-sum (map \#(*' % % % % % % % %) (range 1 100)))" "(some digit-power-sum (map \#(*' % % % % % % % % %) (range 1 100)))" "(some digit-power-sum (map \#(*' % % % % % % % % % %) (range 1 100)))" "(some digit-power-sum (map \#(*' % % % % % % % % % % %) (range 1 100)))" "(filter digit-power-sum (map \#(*' % % % % % % % % % % %) (range 1 100)))" "(filter digit-power-sum (map \#(*' % % % % % % % % % % % %) (range 1 100)))" "(filter digit-power-sum (map \#(*' % % % % % % % % % % % % %) (range 1 100)))" "(filter digit-power-sum (map \#(*' % %) (range 1 100)))" "(filter digit-power-sum (map \#(*' % %) (range 1 1000)))" "(filter digit-power-sum (map \#(*' % %) (range 1 10000)))" "(filter digit-power-sum (map \#(*' % %) (range 1 100000)))" "(filter digit-power-sum (map \#(*' % %) (range 1 1000000)))" "(filter digit-power-sum (map \#(*' % % %) (range 1 1000000)))" "(filter digit-power-sum (map \#(*' % % % %) (range 1 1000000)))" "(filter digit-power-sum (map \#(*' % % % % %) (range 1 100000)))" "(count (take-while \#(< % 10000000) (map \#(* % %) (range))))" "(count (take-while \#(< % 100000000) (map \#(* % %) (range))))" "(count (take-while \#(< % 100000000) (map \#(* % % %) (range))))" "(count (take-while \#(< % 100000000) (map \#(* % % % %) (range))))" "(pow 2 24)" "(pow 2 28)" "(all-powers 10000)" "(all-powers 10)" "(all-powers 20)" "(all-powers 16)" "(all-powers 20)" "(all-powers 12)" "(all-powers 16)" "(all-powers 15)" "(pow 7 28)" "(pow' 7 28)" "(all-powers 15)" "(all-powers 20)" "(all-powers 23)" "(all-powers 24)" "(all-powers 28)" "(filter digit-power-sum (all-powers 28))" "(filter digit-power-sum (all-powers 30))" "(filter digit-power-sum (all-powers 32))" "(filter digit-power-sum (all-powers 36))" "(drop 3 (filter digit-power-sum (all-powers 36)))" "(count (drop 3 (filter digit-power-sum (all-powers 36))))" "(count (drop 3 (filter digit-power-sum (all-powers 42))))" "(count (drop 3 (filter digit-power-sum (all-powers 48))))" "(all-digit-power-sums 2 100000000)" "(all-digit-power-sums 2 1000000)" "(all-digit-power-sums 2 10000000)" "(all-digit-power-sums 3 10000000)" "(source filter)" "(all-digit-power-sums 4 10000000)" "(all-digit-power-sums 2 10000)" "(all-digit-power-sums 2 100000)" "(all-digit-power-sums 2 1000000)" "(all-digit-power-sums 2 10000000)" "(all-digit-power-sums 3 10000)" "(all-digit-power-sums 3 100000)" "(all-digit-power-sums 3 1000000)" "(all-digit-power-sums 4 100000)" "(all-digit-power-sums 5 100000)" "(all-digit-power-sums 6 100000)" "(all-digit-power-sums 7 100000)" "(all-digit-power-sums 8 100000)" "(all-digit-power-sums 9 100000)" "(all-digit-power-sums 10 100000)" "(all-powers 10)" "(all-powers 100)" "(all-powers 16)" "(pow 2 10)" "(all-powers 11)" "(all-powers 12)" "(all-powers 20)" "(all-powers 25)" "(all-powers 34)" "(all-powers 38)" "(count (all-powers 38))" "(count (all-powers 41))" "(count (all-powers 46))" "(count (all-powers 48))" "(def ap (all-powers 48))" "(count ap)" "(def ap (all-powers 49))" "(count ap)" "ap" "(pow 2 (/ 48 3))" "(all-powers 23)" "(nth 29 (all-powers 23))" "(nth (all-powers 23) 29)" "(nth (all-powers) 29)" "(def primes-less-than-10-digits (take-while \#(< % 1000000000) primes))" "(count primes-less-than-10-digits)" "(quot 123121N 4234232423423423423423423N)" "(oracle-prime-factors 10000)" "(radical 1)" "(radical 2)" "(radical 4)" "(radical 5)" "(radical 7)" "(radical 9)" "(nth (sort (map \#(vector (radical %) %) (range 1 100001))) 9999)" "(reversible-number 36)" "(count (filter reversible-number (range 1000)))" "(count (keep reversible-number (range 1000)))" "(reversible-number 1)" "(reversible-number 5)" "(keep reversible-number (range 1 1000))" "(keep reversible-number (range 1 1001))" "(count (keep reversible-number (range 1 1001)))" "(+ 14 41)" "(count (keep reversible-number (range 1 1001)))" "(count (keep reversible-number (range 1 1000000)))" "(count (keep reversible-number (range 1 1000000000)))" "(count (keep reversible-number (range 1 10000000)))" "(count (keep reversible-number (range 1 1001)))" " (keep reversible-number (range 1 1001))" "(time (count (keep reversible-number (range 1 1001))))" "(time (count (keep reversible-number (range 1 10001))))" "(time (count (keep reversible-number (range 1 100001))))" "(time (count (keep reversible-number (range 1 1000001))))" "(time (count (keep reversible-number (range 1 10000001))))" "(time (count (keep reversible-number (range 1 10000001 2))))" "(time (count (keep reversible-number (range 1 100000001 2))))" "(pow 6 9)" "(power-modulo 6 9 10000)" "(power-modulo 1777 1855 100000000)" "(pow' 1777 1855)" "(pow' 1777 (pow' 1777 1855))" "(map \#(pow' 1777 %) (range 1 20))" "(totient 400)" "(totient 1000)" "(totient 10000000)" "(totient 100000000)" "(tetrate-modulo 1777 1855 100000000)" "(tetrate-modulo 3 3 100000000)" "(time (euler-72))" "(time (euler-72-hard-recur))" "(euler-204)" "(time (euler-204))"]
eclipse.preferences.version=1
